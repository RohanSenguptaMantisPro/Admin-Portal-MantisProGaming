import 'package:admin_portal_mantis_pro_gaming/src/authentication/domain/usecases/cache_user_token.dart';
import 'package:admin_portal_mantis_pro_gaming/src/authentication/domain/usecases/create_user.dart';
import 'package:admin_portal_mantis_pro_gaming/src/authentication/domain/usecases/is_admin.dart';
import 'package:admin_portal_mantis_pro_gaming/src/authentication/domain/usecases/is_user_logged_in.dart';
import 'package:bloc/bloc.dart';
import 'package:dart_mappable/dart_mappable.dart';
import 'package:flutter/cupertino.dart';

part 'authentication_event.dart';

part 'authentication_state.dart';

//generated by dart_mappable
part 'authentication_bloc.mapper.dart';

class AuthBloc extends Bloc<AuthEvent, AuthState> {
  AuthBloc({
    required CreateUser createUser,
    required IsAdmin isAdmin,
    required CacheUserToken cacheUserToken,
    required IsUserLoggedIn isUserLoggedIn,
  })  : _createUser = createUser,
        _isAdmin = isAdmin,
        _cacheUserToken = cacheUserToken,
        _isUserLoggedIn = isUserLoggedIn,
        super(const AuthInitial()) {
    on<AuthEvent>((event, emit) {
      emit(const AuthLoading());
    });
    on<CreateUserEvent>(_createUserHandler);
    on<IsAdminEvent>(_isAdminHandler);
    on<CacheUserTokenEvent>(_cacheUserTokenHandler);
    on<IsUserLoggedInEvent>(_isUserLoggedInHandler);
  }

  final CreateUser _createUser;
  final IsAdmin _isAdmin;
  final CacheUserToken _cacheUserToken;
  final IsUserLoggedIn _isUserLoggedIn;

  Future<void> _createUserHandler(
    CreateUserEvent event,
    Emitter<AuthState> emit,
  ) async {
    final result = await _createUser();
    debugPrint('------- $result');
    debugPrint('------- emitting new state');
    result.fold(
      (failure) => emit(AuthError(failure.errorMessage)),
      (userToken) => emit(CreatedUser(userToken: userToken)),
    );
  }

  Future<void> _isAdminHandler(
    IsAdminEvent event,
    Emitter<AuthState> emit,
  ) async {
    final result = await _isAdmin(event.userToken);
    result.fold(
      (failure) => emit(AuthError(failure.errorMessage)),
      (isUserAdmin) => emit(AdminCheckStatus(isAdmin: isUserAdmin)),
    );
  }

  Future<void> _cacheUserTokenHandler(
    CacheUserTokenEvent event,
    Emitter<AuthState> emit,
  ) async {
    final result = await _cacheUserToken(event.userToken);
    result.fold(
      (failure) => emit(AuthError(failure.errorMessage)),
      (_) => emit(const CachedUserToken()),
    );
  }

  Future<void> _isUserLoggedInHandler(
    IsUserLoggedInEvent event,
    Emitter<AuthState> emit,
  ) async {
    emit(const CheckingIsUserLoggedIn());

    final result = await _isUserLoggedIn();
    result.fold(
      (failure) => emit(const LoggedInCheckFailed()),
      (isUserLoggedIn) => emit(IsLoggedInStatus(isLoggedIn: isUserLoggedIn)),
    );
  }
}
